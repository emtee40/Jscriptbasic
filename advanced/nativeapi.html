<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 | Generated by Apache Maven Doxia at Oct 9, 2012
 | Rendered using Apache Maven Fluido Skin 1.2.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>jScriptBasic - jScriptBasic Project Documentation</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />

      
    <script type="text/javascript" src="../js/apache-maven-fluido.min.js"></script>

    
      <meta name="author" content="Peter Verhas" />
    <meta name="Date-Creation-yyyymmdd" content="20120826" />
    <meta name="Date-Revision-yyyymmdd" content="20121009" />
    <meta http-equiv="Content-Language" content="en" />
    
        </head>
        <body class="topBarDisabled">
          
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                    <a href="http://scriptbasic.com" id="bannerLeft">
                                                                                                <img src="../"  alt="ScriptBasic for Java"/>
                </a>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
            
                  <li id="publishDate">Last Published: 2012-10-09</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 1.0.4-SNAPSHOT</li>
                      
                
            
      
                                  
    <li class="pull-right">              <a href="http://scriptbasic.com" class="externalLink" title="ScriptBasic">ScriptBasic</a>
  </li>

                        </ul>
      </div>

            <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
            
                                    <h3>Documentation for SB4J</h3>
                  <ul>
                  <li class="none">
                          <a href="../intro.html" title="Introduction">Introduction</a>
            </li>
                  <li class="none">
                          <a href="../name.html" title="Name of the game">Name of the game</a>
            </li>
                  <li class="none">
                          <a href="../design.html" title="History and Design Goals">History and Design Goals</a>
            </li>
                  <li class="none">
                          <a href="../basic.html" title="Basic Language Implemented">Basic Language Implemented</a>
            </li>
                  <li class="none">
                          <a href="../install.html" title="Installation">Installation</a>
            </li>
                  <li class="none">
                          <a href="../advanced/index.html" title="Embedding API">Embedding API</a>
            </li>
                  <li class="none">
                          <a href="../configure.html" title="Configuration">Configuration</a>
            </li>
          </ul>
                        <h3>Project Documentation</h3>
                  <ul>
                                                                                                                                                                                                                                                        <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                      <li class="collapsed">
                          <a href="../project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                      
            
                
          <hr class="divider" />

           <div id="poweredBy">
                   
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>

    
    <div class="g-plusone" data-href="http://www.scriptbasic.com" data-size="tall" ></div>

                   <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
        <div id="bodyColumn"  class="span9" >
                                  
            <div class="section"><h2>How to embed ScriptBasic for Java using the Native API<a name="How_to_embed_ScriptBasic_for_Java_using_the_Native_API"></a></h2><p>Even though most of the features can be used using the JSR223 ineterface of ScriptBasic for Java, there are some features that are not available via the standard interface. The reason for this is that these features are above the functionality of what the standard can handle.</p><p>For example the standard interfaces do not provide any possibility to define for a script to refer to other script. When you want to execute a script that 'includes' or 'imports' other scripts then there has to be some way to define where the included script is. It can be on the local disk on the file system, in a database or somewhere over the network. There is no such feature in the standard interface.</p><p>To use ScriptBasic for Java using the native API you have to have the ScriptBasic for Java JAR file on the classpath during execution as well as using development. You may recall that using ScriptBasic for Java via the standard interface does not require any ScriptBasic specific in the development environment. In case of the native API you need the JAR.</p><div class="section"><h3>Using Maven<a name="Using_Maven"></a></h3><p>If you use Maven then you can simply define in your POM file that references the actual version of ScriptBasic for Java:</p><div><pre>        &lt;dependencies&gt;
                &lt;dependency&gt;
                &lt;groupId&gt;com.scriptbasic&lt;/groupId&gt;
                &lt;artifactId&gt;jscriptbasic&lt;/artifactId&gt;
                &lt;version&gt;1.0.4-SNAPSHOT&lt;/version&gt;
                &lt;/dependency&gt;
        &lt;/dependencies&gt;</pre></div><p>The artifacts are uploaded into the central repository maintained by Sonatype.</p></div><div class="section"><h3>Using ANT<a name="Using_ANT"></a></h3><p>Go to the web interface of the central repository of Sonatype and download the artifact</p><div><pre>  http://central.maven.org/maven2/com/scriptbasic/jscriptbasic/1.0.4-SNAPSHOT/jscriptbasic-1.0.4-SNAPSHOT.jar </pre></div><p>place it to where the other library files are.</p></div><div class="section"><h3>Embedding API<a name="Embedding_API"></a></h3><p>Using the native API of ScriptBasic for Java you should use the methods defined in the interface <tt>com.scriptbasic.interfaces.EngineApi</tt>. This interface is implemented by the class <tt>com.scriptbasic.Engine</tt>. In the following sections we will have a look at how to use this class </p><ul><li>to execute a program<ul><li>from a string</li><li>from a <tt>java.io.Reader</tt></li><li>from a file (<tt>java.io.File</tt>)</li></ul></li><li>execute a program that includes other files<ul><li>specifying directories as path</li><li>specifying a ScriptBasic specific <tt>SourcePath</tt>, which is something similar to the java ClassPath</li><li>specifying a ScriptBasic specific <tt>SourceProvider</tt>, which is something similar to a Java ClassLoader </li></ul></li></ul><p>We will also have a look at how to set global variables before executing the program, and how to get values of global variables after the code was executed. We will also see how to list all the global variables and also how to invoke a subroutine after the code was executed. Calling subroutines is possible passing arguments and getting return values.</p><div class="section"><h4>Hello world<a name="Hello_world"></a></h4><p>The simplest ever use of the ScriptBasic for Java native API is to execute a script that is available in a string:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;print \&quot;hello world\&quot;&quot;);
</pre></div><p>This code creates a new <tt>Engine</tt> object, then calls the method <tt>eval</tt> with the string that contains the program code. Note that <tt>EngineApi</tt> is an interface and <tt>Engine</tt> is the implementation. If you want to have the output of the program in a <tt>String</tt> you can create a <tt>StringWriter</tt> and redirect the standard output of the program to there:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		engine.eval(&quot;print \&quot;hello world\&quot;&quot;);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>When you do not have the code in a string you can tell the interpreter to execute the code reading the BASIC program from a <tt>java.io.Reader</tt>:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		StringReader sr = new StringReader(&quot;print \&quot;hello world\&quot;&quot;);
		engine.eval(sr);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>or from a <tt>java.io.File</tt>:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		File file = new File(getClass().getResource(&quot;hello.bas&quot;).getFile());
		engine.eval(file);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>Note that the sample above is included from a junit test file. When you use this API you will much easier get to your file name than <tt>this.getClass().getResource(&quot;hello.bas&quot;).getFile()</tt>.</p></div><div class="section"><h4>Including files<a name="Including_files"></a></h4><p>When a BASIC file includes another you can not use the above methods. Even though the method <tt>eval(File file)</tt> could handle an include statement and include the other BASIC script from the same directory where the first file is, it does not and it does it for good reason. The reason is called security. When you use the above, simple methods you need not fear that your BASIC program gets feral.</p><p>When you want to execute more complex programs that rely on other BASIC codes that are <tt>include</tt>-ed or <tt>import</tt>-ed into the original BASIC code then you have to specify the source path where to look for these files. Using the native API you have three opportunities:</p><ul><li>define the directories as a string array (variable arguments method)</li><li>define the directories supplying a <tt>SourcePath</tt> object that may calculate the list of directories on the fly. </li><li>define a <tt>SourceProvider</tt> object that reads the content from any source you want.</li></ul><p>The latter you select the more flexibility you have, and the more programming you face.</p><p>To specify the directories where the files are use the following piece of code:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		String path = new File(getClass().getResource(&quot;hello.bas&quot;).getFile())
				.getParent();
		engine.eval(&quot;include.bas&quot;, path);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>Since the last parameter is variable argument, you can use there <tt>String[]</tt> array, or simply as many <tt>String</tt> parameters as you like:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;include.bas&quot;, &quot;.&quot;, &quot;..&quot;, &quot;/usr/include/scriptbasic&quot;);
</pre></div><p>The second possibility is to provide a <tt>SourcePath</tt> object. The following sample shows you a very simple use of this approach:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		String path = new File(getClass().getResource(&quot;hello.bas&quot;).getFile())
				.getParent();
		SourcePath sourcePath = new BasicSourcePath();
		sourcePath.add(path);
		engine.eval(&quot;include.bas&quot;, sourcePath);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>Actually this way of use has no advantage of this method over the previous one where you provided the path values as strings. However there is nothing to stop you to create your own class implementing the interface <tt>SourcePath</tt>. In that case this method can be used to deliver the different locations via your class.</p><p>The third and most powerful approach is to provide your own implementation of the <tt>SourceProvider</tt>. This is the only approach when your BASIC code is not in the file system, and you can not simply provide a <tt>java.io.Reader</tt> to the source code because the file may include other BASIC files. The sample code that does this is the following:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		SourceProvider provider = new SourceProvider() {
			private Map&lt;String, String&gt; source = new HashMap&lt;String, String&gt;();
			{
				source.put(&quot;hello.bas&quot;, &quot;print \&quot;hello world\&quot;&quot;);
				source.put(&quot;include.bas&quot;, &quot;include \&quot;hello.bas\&quot;&quot;);
			}

			@Override
			public Reader get(String sourceName, String referencingSource)
					throws IOException {
				return get(sourceName);
			}

			@Override
			public Reader get(String sourceName) throws IOException {
				GenericReader reader = new GenericReader();
				reader.setSourceProvider(this);
				reader.set(new StringReader(source.get(sourceName)));
				return reader;
			}
		};
		engine.eval(&quot;include.bas&quot;, provider);
		sw.close();
		Assert.assertEquals(&quot;hello world&quot;, sw.toString());
</pre></div><p>This sample code implements an anonymous class of the interface <tt>SourceProvider</tt> implementing both of the <tt>get</tt> methods. Note that these methods return a BASIC <tt>Reader</tt> and not a <tt>java.io.Reader</tt>. The actual implementation contains a mini file system in itself containing two files: <tt>include.bas</tt> and <tt>hello.bas</tt> stored in a hash map. The method <tt>get(String sourceName)</tt> reads the one that is named and creates a <tt>GenericReader</tt> implemented in ScriptBasic for Java.</p><p>Note that your implementation of a <tt>SourceProvider</tt> will, probably be more complex than this one. The algorithm implemented in the methods <tt>get(String sourceName)</tt> and in <tt>get(String sourceName,String referencingSource)</tt> may search the script content in file, in database or in any other type of repository using the <tt>sourceName</tt> as an absolute identifying string for the source or as a string that identifies the script together with the identifying string of the script that includes the other string (<tt>referencingSource</tt>).</p><p>When you design the store for your scripts you need not stick to the syntax of the file names and directories. If you have a good reason to use different naming convention for your script entities in your script store you are free.</p></div><div class="section"><h4>Setting global variables<a name="Setting_global_variables"></a></h4><p>Before executing the program you can set the values of certain global variables. These variables will be available for the script exactly as it was set by some BASIC code. To do so the following sample can be used:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		StringWriter sw = new StringWriter(10);
		engine.setOutput(sw);
		engine.setVariable(&quot;a&quot;, 13);
		engine.eval(&quot;print a + \&quot;hello world\&quot;&quot;);
		sw.close();
		Assert.assertEquals(&quot;13hello world&quot;, sw.toString());
</pre></div><p>To set the variable you should pass a Java <tt>Object</tt> to the method. Whenever you pass a primitive it will be autoboxed to an <tt>Object</tt> and ScriptBasic for Java will convert it to a BASIC object. The conversion is automatic. <tt>Byte</tt>, <tt>Short</tt> and <tt>Integer</tt> values are converted to <tt>Long</tt>. <tt>Float</tt> values are converted to <tt>Double</tt>. <tt>Character</tt> values are converted to <tt>String</tt>. If you happen to pass a <tt>RightValue</tt> to the method <tt>setVariable()</tt> then it will be stored without conversion. Any other objects will be wrapped into a new <tt>RightValue</tt> and will be accessible from the BASIC code as a Java Object: you can access fields <tt>X.field</tt> or you can call methods of the object <tt>X.method()</tt>. </p><p>After the code was executed you are able to query the values of the global variables:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;a = \&quot;hello world\&quot;&quot;);
		String a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertEquals(&quot;hello world&quot;, a);
</pre></div><p>In this way the BASIC object represented by the ScriptBasic for Java internal class <tt>RightValue</tt> is converted to a plain Java object. This plain java object can be <tt>Long</tt>, <tt>Double</tt>, <tt>Character</tt>, <tt>String</tt> or <tt>Boolean</tt>.</p><p>ScriptBasic for Java does not use <tt>Byte</tt>, <tt>Short</tt>, <tt>Integer</tt>, <tt>Character</tt> and <tt>Float</tt> values internally therefore a number that you may get as a return value of a subroutine (see that later) or as the value of a global variable can only be <tt>Long</tt> or <tt>Double</tt> and character variable can only be <tt>String</tt>.</p><p>A BASIC object however can also contain arbitrary objects as well. In that case you will get the object itself without conversion. It may be an object you set before the execution of the code but it can also be an object returned by a Java method that was called as BASIC function or as a method on an object injected into the code before execution calling the method <tt>setVariable()</tt>.</p><p>If you do not know the name of the global variable beforehand you can list the names of the global variables after the execution of the code programmatically:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;a = \&quot;hello world\&quot;\nb=13&quot;);
		String varnames = &quot;&quot;;
		for (String varname : engine.getVariablesIterator()) {
			varnames += varname;
		}
		Assert.assertTrue(varnames.indexOf('a') != -1);
		Assert.assertTrue(varnames.indexOf('b') != -1);
		Assert.assertEquals(2, varnames.length());
</pre></div><p>The value returned by the method <tt>engine.getVariablesIterator()</tt> is an iterator that you can use in <tt>for</tt> loops or in any other Java way to iterate through the names of the global variables.</p></div><div class="section"><h4>Loading code<a name="Loading_code"></a></h4><p>If you want to load a BASIC program ready for execution, but do not want to execute yet, you can call the method <tt>load()</tt>. For every method <tt>eval()</tt> there is a method names <tt>load()</tt> handling the same type of arguments. The method <tt>load()</tt> only loads the code, performs all analysis that are needed to execute the code, but does not execute it. To execute the code you can call the method <tt>execute()</tt>. It is possible to call this method multiple times.</p><p>Using the methods <tt>load()</tt> is also possible when you do not want to execute the main code of a BASIC script, you only want to call subroutines without the execution of the main code.</p></div><div class="section"><h4>Calling a subroutine<a name="Calling_a_subroutine"></a></h4><p>After the code was executed and returned you can call subroutines defined in the BASIC program. Note that ScriptBasic for Java does not distinguish between functions and procedures. There is only <tt>Sub</tt> that may but need not return a value.</p><p>To call a subroutine you have to know the name of the subroutine and you should call the method <tt>call()</tt>:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;sub applePie\nglobal a\na = \&quot;hello world\&quot;\nEndSub&quot;);
		String a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertNull(a);
		engine.call(&quot;applePie&quot;, (Object[]) null);
		a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertEquals(&quot;hello world&quot;, a);
</pre></div><p>This sample shows you how to call a subroutine that does not need any parameter and does not return any value. The next example shows how to pass arguments and how to get the return value:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;sub applePie(b)\nglobal a\na = b\nreturn 6\nEndSub&quot;);
		String a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertNull(a);
		Long ret = (Long) engine.call(&quot;applePie&quot;, &quot;hello world&quot;);
		a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertEquals(&quot;hello world&quot;, a);
		Assert.assertEquals((Long) 6L, ret);
</pre></div><p>If the argument list is too long, you will get an exception. If the argument list is too short then the final arguments not matched by the passed values will be undefined. To get the number of arguments a subroutine expects you should call the method <tt>getNumberOfArguments(String name)</tt> with the subroutine name as argument. To get all the subroutines the BASIC program defines you should call the method <tt>getSubroutineNames()</tt>: </p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;sub applePie(b)\nEndSub\nsub anotherSubroutine\nEndSub\n&quot;);
		int i = 0;
		for (@SuppressWarnings(&quot;unused&quot;)
		String subName : engine.getSubroutineNames()) {
			i++;
		}
		Assert.assertEquals(2, i);
		Assert.assertEquals(1, engine.getNumberOfArguments(&quot;applePie&quot;));
		Assert.assertEquals(0, engine.getNumberOfArguments(&quot;anotherSubroutine&quot;));
</pre></div></div><div class="section"><h4>Calling a subroutine object oriented way<a name="Calling_a_subroutine_object_oriented_way"></a></h4><p>The API calling a subroutine described above is not really object oriented. It helps a lot to write short implementations but for those that are keen on programming in OO style there is another interface in the native ScriptBasic for Java API <tt>Subroutine</tt>. This interface represents a subroutine in a BASIC program and is tied to an <tt>Engine</tt>. To get an instance you have to call the <tt>Engine</tt> method <tt>getSubroutine(String name)</tt>. When you have the instance you can call <tt>call(Object ... args)</tt>, <tt>getName()</tt> and <tt>getNumberOfArguments()</tt> methods.</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;sub applePie\nglobal a\na = \&quot;hello world\&quot;\nEndSub&quot;);
		String a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertNull(a);
		Subroutine applePie = engine.getSubroutine(&quot;applePie&quot;);
		applePie.call((Object[]) null);
		a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertEquals(&quot;hello world&quot;, a);
</pre></div><p>This sample above is the object oriented version of the sample before. Also see the following sample how to call a subroutine in OO way that returns some value:</p><div class="source"><pre class="prettyprint">		EngineApi engine = new Engine();
		engine.eval(&quot;sub applePie(b)\nglobal a\na = b\nreturn 6\nEndSub&quot;);
		String a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertNull(a);
		Subroutine applePie = engine.getSubroutine(&quot;applePie&quot;);
		Long ret = (Long) applePie.call(&quot;hello world&quot;);
		a = (String) engine.getVariable(&quot;a&quot;);
		Assert.assertEquals(&quot;hello world&quot;, a);
		Assert.assertEquals((Long) 6L, ret);
</pre></div></div></div></div>
                  </div>
            </div>
      
    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span16">Copyright &copy;                    2012
                        <a href="http://www.verhas.com">Verhas and Verhas Software Craftsmen</a>.
            All Rights Reserved.      
            
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
